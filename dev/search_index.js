var documenterSearchIndex = {"docs":
[{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"","category":"page"},{"location":"KrylovforLinearPDE/#JSOPDESolver","page":"Krylov.jl to solve linear PDE","title":"JSOPDESolver","text":"","category":"section"},{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"using Gridap, Krylov","category":"page"},{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"Set of codes to use JSOSolvers tools to solve partial differential equations modeled with Gridap. It contains examples of:","category":"page"},{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"using Krylov.jl to solve linear PDEs (AffineFEOperator)\nusing Krylov.jl to solve the linear systems in the Newton-loop to solve","category":"page"},{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"nonlinear PDEs.","category":"page"},{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"more...","category":"page"},{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"Pluto notebook examples can be found in the pluto folder.","category":"page"},{"location":"KrylovforLinearPDE/#Krylov.jl-to-solve-linear-PDEs","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDEs","text":"","category":"section"},{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"include(\"header.jl\")\n\n###############################################################################\n#Gridap resolution:\n#This corresponds to a Poisson equation with Dirichlet and Neumann conditions\n#described here: https://gridap.github.io/Tutorials/stable/pages/t001_poisson/\nfunction _poisson()\n    domain = (0,1,0,1)\n    n = 2^7\n    partition = (n,n)\n    model = CartesianDiscreteModel(domain,partition)\n\n    trian = Triangulation(model)\n    degree = 2\n    quad = Measure(trian,degree)\n\n    V0 = TestFESpace(\n      reffe=:Lagrangian, order=1, valuetype=Float64,\n      conformity=:H1, model=model, dirichlet_tags=\"boundary\")\n\n    g(x) = 0.0\n    Ug = TrialFESpace(V0,g)\n\n    w(x) = 1.0\n    a(u,v) = ∇(v)⊙∇(u)\n    b_Ω(v) = v*w\n    t_Ω = AffineFETerm(a,b_Ω,trian,quad)\n\n    op_pde = AffineFEOperator(Ug,V0,t_Ω)\n    return op_pde\nend\n\nop_pde = _poisson()\n\n#Gridap.jl/src/FESpaces/FESolvers.jl\n#Gridap.jl/src/Algebra/LinearSolvers.jl\n@time ls  = KrylovSolver(minres; itmax = 150)\n@time ls1 = LUSolver()\n@time ls2 = BackslashSolver()\n\nsolver  = LinearFESolver(ls)\nsolver1 = LinearFESolver(ls1)\nsolver2 = LinearFESolver(ls2)\n\n#Describe the matrix:\n@test size(get_matrix(op_pde)) == (16129, 16129)\n@test issparse(get_matrix(op_pde))\n@test issymmetric(get_matrix(op_pde))\n\nuh  = solve(solver, op_pde)\nuh1 = solve(solver1,op_pde)\nuh2 = solve(solver2,op_pde)\n#Sad, that we don't have the stats back...\n\n@time uh = solve(solver,op_pde)\nx = get_free_values(uh)\n@time uh1 = solve(solver1,op_pde)\nx1 = get_free_values(uh1)\n@time uh2 = solve(solver2,op_pde)\nx2 = get_free_values(uh2)\n\n@test norm(x  - x1, Inf) <= 1e-8\n@test norm(x1 - x2, Inf) <= 1e-13\n@show norm(get_matrix(op_pde)*x  - get_vector(op_pde),Inf) <= 1e-8\n@test norm(get_matrix(op_pde)*x1 - get_vector(op_pde),Inf) <= 1e-15\n@test norm(get_matrix(op_pde)*x2 - get_vector(op_pde),Inf) <= 1e-15","category":"page"},{"location":"KrylovforLinearPDE/#Krylov.jl-to-solve-the-linear-systems-in-the-Newton-loop-to-solve-nonlinear-PDEs","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve the linear systems in the Newton-loop to solve nonlinear PDEs","text":"","category":"section"},{"location":"KrylovforLinearPDE/","page":"Krylov.jl to solve linear PDE","title":"Krylov.jl to solve linear PDE","text":"include(\"header.jl\")\n\nop = _pdeonlyincompressibleNS()\n\nusing LineSearches\n#Gridap way of solving the equation:\nnls = NLSolver(\n  show_trace=false, method=:newton, linesearch=BackTracking())\nsolver = FESolver(nls)\n\n#struct NewtonRaphsonSolver <:NonlinearSolver\n#  ls::LinearSolver\n#  tol::Float64\n#  max_nliters::Int\n#end\nnls2 = Gridap.Algebra.NewtonRaphsonSolver(LUSolver(), 1e-6, 100)\nsolver2 = FESolver(nls2)\n\n#The first approach is to use Newton method anticipated by Gridap and using\n#Krylov.jl to solve the linear problem.\n#NLSolver(ls::LinearSolver;kwargs...)\nls  = KrylovSolver(cgls; itmax = 10000, verbose = false)\nnls_krylov = NLSolver(ls, show_trace=false)\n@test nls_krylov.ls == ls\nsolver_krylov = FESolver(nls_krylov)\n\nnls_krylov2 = Gridap.Algebra.NewtonRaphsonSolver(ls, 1e-6, 100)\nsolver_krylov2 = FESolver(nls_krylov2)\n\n#Another version is to surcharge:\n#solve!(x::AbstractVector,nls::NewNonlinearSolverType,op::NonlinearOperator,cache::Nothing)\n\n#\n# Finally, we solve the problem:\n#solve(solver, op)\n#solve(solver2, op)\n#solve(solver_krylov, op)\n\n@time uph1 = solve(solver,op)\nsol_gridap1 = get_free_values(uph1);\n@time uph2 = solve(solver2,op)\nsol_gridap2 = get_free_values(uph2);\n@time uph3 = solve(solver_krylov,op)\nsol_gridap3 = get_free_values(uph3);\n@time uph4 = solve(solver_krylov2,op)\nsol_gridap4 = get_free_values(uph4);\n\nnUg = num_free_dofs(op.trial)\n@test size(Gridap.FESpaces.jacobian(op, uph1)) == (nUg, nUg)\n\n@show norm(Gridap.FESpaces.residual(op, uph1),Inf)\n@show norm(Gridap.FESpaces.residual(op, uph2),Inf)\n@show norm(Gridap.FESpaces.residual(op, uph3),Inf)\n@show norm(Gridap.FESpaces.residual(op, uph4),Inf)\n\n@show norm(sol_gridap1 - sol_gridap2, Inf)\n@show norm(sol_gridap1 - sol_gridap3, Inf)\n@show norm(sol_gridap1 - sol_gridap4, Inf)","category":"page"},{"location":"poisson-boltzman/#PDE-contrained-optimization","page":"PDE-constrained optimization","title":"PDE-contrained optimization","text":"","category":"section"},{"location":"poisson-boltzman/#Poisson-Boltzman-problem","page":"PDE-constrained optimization","title":"Poisson-Boltzman problem","text":"","category":"section"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"We consider here a 2D Poisson-Boltzmann problem","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"leftlbrace\nbeginaligned\nminlimits_y in H_0^1(Omega) u in L^2(Omega)     frac12int_Omega y - y_d(x)^2 + frac12alpha int_Omega u^2dx \ntext st   -Delta y + sinhy = h + u quad textin  Omega=(-11)^2\n                   y = 0 quad textin  partialOmega\nendaligned\nright","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"with the forcing term h(x_1x_2)=-sin(omega x_1) sin(omega x_2), omega = pi - frac18, and target state","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"beginaligned\n    y_d(x) = begincases\n    10 quad textif  x in 025075^2 \n    5 quad textotherwise\n    endcases\nendaligned","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"The implementation as a GridapPDENLPModel is given as follows.","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"    using Gridap, PDENLPModels\n    #Domain\n    n = 100\n    model = CartesianDiscreteModel((-1,1,-1,1), (n,n))\n\n    #Definition of the spaces:\n    order = 1\n    valuetype = Float64\n    reffe = ReferenceFE(lagrangian, valuetype, order)\n    Xpde = TestFESpace(\n      model,\n      reffe;\n      conformity = :H1,\n      dirichlet_tags=\"boundary\",\n    )\n    Ypde = TrialFESpace(Xpde, 0.0)\n    Xcon = TestFESpace(model, reffe; conformity = :L2)\n    Ycon = TrialFESpace(Xcon)\n    Y = MultiFieldFESpace([Ypde, Ycon])\n\n    #Integration machinery\n    trian = Triangulation(model)\n    degree = 1\n    dΩ = Measure(trian,degree)\n\n    #Objective function:\n    yd(x) = min(x[1]-0.25, 0.75-x[1],x[2]-0.25, 0.75-x[2])>=0. ? 10. : 5.\n    function f(y, u)\n        ∫( 0.5 * (yd - y) * (yd - y) + 0.5 * 1e-4 * u * u )dΩ\n    end\n\n    #Definition of the constraint operator\n    ω = π - 1/8\n    h(x) = - sin(ω*x[1])*sin(ω*x[2])\n    function res(y, u, v)\n     ∫( ∇(v) ⊙ ∇(y) + (sinh ∘ y)*v - u*v - v * h )dΩ\n    end\n    op = FEOperator(res, Y, Xpde)\n    xin = zeros(Gridap.FESpaces.num_free_dofs(Y))\n    nlp = GridapPDENLPModel(xin, f, trian, Ypde, Ycon, Xpde, Xcon, op)","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"Then, one can solve the problem with Ipopt via NLPModelsIpopt.jl and plot the solution as a VTK file.","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"using NLPModelsIpopt\nstats = ipopt(nlp, print_level = 0)","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"Switching again the discrete solution as a FEFunction the result can written as a VTK-file using Gridap's facilities.","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"yfv = stats.solution[1:Gridap.FESpaces.num_free_dofs(nlp.pdemeta.Ypde)]\nyh  = FEFunction(nlp.pdemeta.Ypde, yfv)\nufv = stats.solution[1+Gridap.FESpaces.num_free_dofs(nlp.pdemeta.Ypde):end]\nuh  = FEFunction(nlp.pdemeta.Ycon, ufv)\nwritevtk(nlp.pdemeta.tnrj.trian,\"results\",cellfields=[\"uh\"=>uh, \"yh\"=>yh])","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"Finally, the solution is obtained using any software reading VTK, e.g. Paraview.","category":"page"},{"location":"poisson-boltzman/","page":"PDE-constrained optimization","title":"PDE-constrained optimization","text":"(Image: Solution of P-B equation)(Image: Control of P-B equation)","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PDENLPModels]\nPrivate = false","category":"page"},{"location":"reference/#PDENLPModels.EnergyFETerm","page":"Reference","title":"PDENLPModels.EnergyFETerm","text":"FETerm modeling the objective function of the optimization problem.\n\nbeginaligned\nint_Omega f(yu) dOmega\nendaligned\n\nConstructor:\n\nEnergyFETerm(:: Function, :: Triangulation, :: Measure)\n\nSee also: MixedEnergyFETerm, NoFETerm, _obj_cell_integral, _obj_integral, _compute_gradient_k!\n\n\n\n\n\n","category":"type"},{"location":"reference/#PDENLPModels.GridapPDENLPModel","page":"Reference","title":"PDENLPModels.GridapPDENLPModel","text":"PDENLPModels using Gridap.jl\n\nhttps://github.com/gridap/Gridap.jl Cite: Badia, S., & Verdugo, F. (2020). Gridap: An extensible Finite Element toolbox in Julia. Journal of Open Source Software, 5(52), 2520.\n\nFind functions (y,u): Y -> ℜⁿ x ℜⁿ and κ ∈ ℜⁿ satisfying\n\nmin      ∫_Ω​ f(κ,y,u) dΩ​ s.t.     y solution of a PDE(κ,u)=0          lcon <= c(κ,y,u) <= ucon          lvar <= (κ,y,u)  <= uvar\n\n     ```math\n     \\begin{aligned}\n     \\min_{κ,y,u} \\ & ∫_Ω​ f(κ,y,u) dΩ​ \\\\\n     \\mbox{ s.t. } & y \\mbox{ solution of } PDE(κ,u)=0, \\\\\n     & lcon <= c(κ,y,u) <= ucon, \\\\\n     & lvar <= (κ,y,u)  <= uvar.\n     \\end{aligned}\n     ```\n\nThe weak formulation is then: res((y,u),(v,q)) = ∫ v PDE(κ,y,u) + ∫ q c(κ,y,u)\n\nwhere the unknown (y,u) is a MultiField see Tutorials 7  and 8 of Gridap.\n\nMain constructor:\n\nGridapPDENLPModel(:: NLPModelMeta, :: Counters, :: AbstractEnergyTerm, :: FESpace, :: Union{FESpace,Nothing}, :: FESpace, :: Union{FESpace,Nothing}, :: FESpace, :: Union{FESpace,Nothing}, :: Union{FEOperator, Nothing}, :: Int, :: Int, :: Int) \n\nThe following keyword arguments are available to all constructors:\n\nname: The name of the model (default: \"Generic\")\n\nThe following keyword arguments are available to the constructors for constrained problems:\n\nlin: An array of indexes of the linear constraints\n\n(default: Int[] or 1:ncon if c is an AffineFEOperator)\n\nThe following keyword arguments are available to the constructors for constrained problems explictly giving lcon and ucon:\n\ny0: An inital estimate to the Lagrangian multipliers (default: zeros)\n\nNotes:\n\nWe handle two types of FEOperator: AffineFEOperator, and FEOperatorFromWeakForm\nIf lcon and ucon are not given, they are assumed zeros.\nIf the type can't be deduced from the argument, it is Float64.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PDENLPModels.MixedEnergyFETerm","page":"Reference","title":"PDENLPModels.MixedEnergyFETerm","text":"FETerm modeling the objective function of the optimization problem with functional and discrete unknowns.\n\nbeginaligned\nint_Omega f(yukappa) dOmega\nendaligned\n\nConstructor:\n\nMixedEnergyFETerm(:: Function, :: Triangulation, :: Int)\n\nSee also: EnergyFETerm, NoFETerm, _obj_cell_integral, _obj_integral, _compute_gradient_k!\n\n\n\n\n\n","category":"type"},{"location":"reference/#PDENLPModels.NoFETerm","page":"Reference","title":"PDENLPModels.NoFETerm","text":"FETerm modeling the objective function when there are no integral objective.\n\nmath \\begin{aligned}  f(\\kappa) \\end{aligned}\n\nConstructors:\n\nNoFETerm()\n\nNoFETerm(:: Function)\n\nSee also: MixedEnergyFETerm, EnergyFETerm, _obj_cell_integral, _obj_integral, _compute_gradient_k!\n\n\n\n\n\n","category":"type"},{"location":"reference/#PDENLPModels.bounds_functions_to_vectors-Tuple{Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace, Gridap.FESpaces.FESpace, Gridap.Geometry.Triangulation, Function, Function, Function, Function}","page":"Reference","title":"PDENLPModels.bounds_functions_to_vectors","text":"(lvar, uvar) = bounds_functions_to_vectors(Y :: MultiFieldFESpace, Ycon :: Union{FESpace, Nothing},  Ypde :: FESpace, trian :: Triangulation, lyfunc :: Union{Function, AbstractVector}, uyfunc :: Union{Function, AbstractVector}, lufunc :: Union{Function, AbstractVector}, uufunc :: Union{Function, AbstractVector})\n\nReturn the bounds lvar and uvar.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Hcols-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Hcols","text":"get_Hcols(nlp)\nget_Hcols(meta)\n\nReturn the value Hcols from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Hrows-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Hrows","text":"get_Hrows(nlp)\nget_Hrows(meta)\n\nReturn the value Hrows from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Jcols-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Jcols","text":"get_Jcols(nlp)\nget_Jcols(meta)\n\nReturn the value Jcols from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Jrows-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Jrows","text":"get_Jrows(nlp)\nget_Jrows(meta)\n\nReturn the value Jrows from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_X-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_X","text":"get_X(nlp)\nget_X(meta)\n\nReturn the value X from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Xcon-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Xcon","text":"get_Xcon(nlp)\nget_Xcon(meta)\n\nReturn the value Xcon from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Xpde-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Xpde","text":"get_Xpde(nlp)\nget_Xpde(meta)\n\nReturn the value Xpde from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Y-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Y","text":"get_Y(nlp)\nget_Y(meta)\n\nReturn the value Y from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Ycon-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Ycon","text":"get_Ycon(nlp)\nget_Ycon(meta)\n\nReturn the value Ycon from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_Ypde-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_Ypde","text":"get_Ypde(nlp)\nget_Ypde(meta)\n\nReturn the value Ypde from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_nnzh_obj-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_nnzh_obj","text":"get_nnzh_obj(nlp)\nget_nnzh_obj(meta)\n\nReturn the value nnzh_obj from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_nparam-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_nparam","text":"get_nparam(nlp)\nget_nparam(meta)\n\nReturn the value nparam from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_nvar_con-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_nvar_con","text":"get_nvar_con(nlp)\nget_nvar_con(meta)\n\nReturn the value nvar_con from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_nvar_pde-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_nvar_pde","text":"get_nvar_pde(nlp)\nget_nvar_pde(meta)\n\nReturn the value nvar_pde from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_op-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_op","text":"get_op(nlp)\nget_op(meta)\n\nReturn the value op from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.get_tnrj-Tuple{PDENLPModels.PDENLPMeta}","page":"Reference","title":"PDENLPModels.get_tnrj","text":"get_tnrj(nlp)\nget_tnrj(meta)\n\nReturn the value tnrj from meta or nlp.meta.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PDENLPModels.split_vectors-Tuple{GridapPDENLPModel, AbstractVector}","page":"Reference","title":"PDENLPModels.split_vectors","text":"`split_vectors(::GridapPDENLPModel, x)`\n\nTake a vector x and returns a splitting in terms of y, u and θ.\n\n\n\n\n\n","category":"method"},{"location":"tore/#Calculus-of-Variations","page":"Calculus of Variations","title":"Calculus of Variations","text":"","category":"section"},{"location":"tore/#The-Brachistochrone-over-a-Tore","page":"Calculus of Variations","title":"The Brachistochrone over a Tore","text":"","category":"section"},{"location":"tore/","page":"Calculus of Variations","title":"Calculus of Variations","text":"In this example, we present how to model the classical brachistochrone problem over the torus with PDENLPModels.jl in polar coordinates. We want to model the following problem:","category":"page"},{"location":"tore/","page":"Calculus of Variations","title":"Calculus of Variations","text":"leftlbrace\nbeginaligned\nmin_varphi theta    int_0^1 a^2 dotvarphi^2 + (c + a cos(varphi))^2 dottheta^2dt\n  0 leq theta varphi leq 2pi\n  varphi(0)= 0 varphi(1)= pi\n  theta(0) = 0 theta(1) = pi\nendaligned\nright","category":"page"},{"location":"tore/","page":"Calculus of Variations","title":"Calculus of Variations","text":"with a=1 and c=3.","category":"page"},{"location":"tore/","page":"Calculus of Variations","title":"Calculus of Variations","text":"  using Gridap, PDENLPModels\n\n  n = 100 #discretization size\n  domain = (0,1) \n  model = CartesianDiscreteModel(domain, n)\n      \n  labels = get_face_labeling(model)\n  add_tag_from_tags!(labels,\"diri1\",[2])\n  add_tag_from_tags!(labels,\"diri0\",[1])\n\n  x0 = zeros(2) # initial values\n  xf = π * ones(2) # final values\n  \n  order = 1\n  valuetype = Float64\n  reffe = ReferenceFE(lagrangian, valuetype, order)\n  V0 = TestFESpace(\n    model,\n    reffe;\n    conformity = :H1,\n    dirichlet_tags=[\"diri0\",\"diri1\"],\n  )\n  V1 = TestFESpace(\n    model,\n    reffe;\n    conformity = :H1,\n    dirichlet_tags=[\"diri0\",\"diri1\"],\n  )\n  \n  U0  = TrialFESpace(V0, [x0[1], xf[1]])\n  U1  = TrialFESpace(V0, [x0[2], xf[2]])\n  \n  V = MultiFieldFESpace([V0, V1])\n  U = MultiFieldFESpace([U0, U1])\n  nU0 = Gridap.FESpaces.num_free_dofs(U0)\n  nU1 = Gridap.FESpaces.num_free_dofs(U1)\n  \n  trian = Triangulation(model)\n  degree = 1\n  dΩ = Measure(trian, degree)\n\n  # The function under the integral:\n  # To use the function cos in Gridap: `operate(cos, x)` vaut cos(x)\n  # The square function is not available, so: `x*x` holds for $x^2$, \n  # and `∇(φ) ⊙ ∇(φ)` for `φ'^2`.\n  a = 1\n  c = 3\n  function f(x)\n    φ, θ = x\n    ∫(a * a * ∇(φ) ⊙ ∇(φ) + (c + a * (cos ∘ φ)) * (c + a * (cos ∘ φ)) * ∇(θ) ⊙ ∇(θ))dΩ\n  end\n\n  # boundaries\n  xmin = 0\n  xmax = 2*π\n  \n  nlp = GridapPDENLPModel(\n    zeros(nU0 + nU1),\n    f,\n    trian,\n    U,\n    V,\n    lvar = xmin * ones(nU0+nU1),\n    uvar = xmax * ones(nU0+nU1),\n  )","category":"page"},{"location":"tore/","page":"Calculus of Variations","title":"Calculus of Variations","text":"Then, one can solve the problem with Ipopt via NLPModelsIpopt.jl and plot the solution.","category":"page"},{"location":"tore/","page":"Calculus of Variations","title":"Calculus of Variations","text":"using NLPModelsIpopt\n\nstats = ipopt(nlp, print_level = 0)\n\nnn = Int(nlp.pdemeta.nvar_pde/2)\nφs = stats.solution[1:nn]\nθs = stats.solution[nn+1:2*nn]\n\nxs = (c .+ a * cos.(φs)) .* cos.(θs)\nys = (c .+ a * cos.(φs)) .* sin.(θs)\nzs = a * sin.(φs)\n\nL = stats.objective\n\nplotlyjs()\n\nlinspace(from, to, npoints) = range(from, stop=to, length=npoints)\n\n#plot a torus\nM = 100\nαs = linspace(0, 2π, M)\nβs = linspace(0, 2π, M)\nXs = (c .+ a * cos.(αs)) * cos.(βs)'\nYs = (c .+ a * cos.(αs)) * sin.(βs)'\nZs = (a * sin.(αs)) * ones(M)'\nplot3d(Xs, Ys, Zs, st=:surface, grid=false, c=:grays, axis=false, colorbar=false)\nplot3d!(xs, ys, zs, linewidth=4, color=:red, title=@sprintf(\"Geodesic on a Torus (length=%4.f)\", L), legend=false)","category":"page"},{"location":"tore/","page":"Calculus of Variations","title":"Calculus of Variations","text":"(Image: Geodesic over the tore)","category":"page"},{"location":"#PDENLPModels.jl-Documentation","page":"Introduction","title":"PDENLPModels.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PDENLPModels specializes the NLPModel API to optimization problem with partial differential equation in the constraints. The package relies on Gridap.jl for the modeling and the computation of the derivatives.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We consider optimization problems of the form: find functions (y,u) and κ ∈ ℜⁿ satisfying","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"leftlbrace\nbeginaligned\nminlimits_κyu    int_Omega f(κyu)dx \ntext st   texty solution of a PDE(κu)\n                   lcon leq c(κyu) leq ucon\n                   lvar leq (κyu)  leq uvar\nendaligned\nright","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"] add PDENLPModels","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The current version of PDENLPModels relies on Gridap v0.15.5.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We refer to the folder test/problems for more examples of problems of different types: calculus of variations, optimal control problem, PDE-constrained problems, and mixed PDE-contrained problems with both function and vector unknowns. Without objective function, the problem reduces to a classical PDE and we refer to Gridap tutorials for examples.","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"https://github.com/gridap/Gridap.jl Badia, S., & Verdugo, F. (2020). Gridap: An extensible Finite Element toolbox in Julia. Journal of Open Source Software, 5(52), 2520.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"https://github.com/JuliaSmoothOptimizers/NLPModels.jl D. Orban and A. S. Siqueira and {contributors} (2020). NLPModels.jl: Data Structures for Optimization Models","category":"page"}]
}
