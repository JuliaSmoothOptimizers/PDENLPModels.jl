<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · PDENLPModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">PDENLPModels.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="nlpmodels/">PDENLPModels Progress</a></li><li><a class="tocitem" href="KrylovforLinearPDE/">Krylov.jl to solve linear PDE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tmigot/PDENLPModels.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PDENLPModels.jl-Documentation"><a class="docs-heading-anchor" href="#PDENLPModels.jl-Documentation">PDENLPModels.jl Documentation</a><a id="PDENLPModels.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#PDENLPModels.jl-Documentation" title="Permalink"></a></h1><ul><li><a href="KrylovforLinearPDE/#JSOPDESolver">JSOPDESolver</a></li><ul><li><a href="KrylovforLinearPDE/#Krylov.jl-to-solve-linear-PDEs">Krylov.jl to solve linear PDEs</a></li><li><a href="KrylovforLinearPDE/#Krylov.jl-to-solve-the-linear-systems-in-the-Newton-loop-to-solve-nonlinear-PDEs">Krylov.jl to solve the linear systems in the Newton-loop to solve nonlinear PDEs</a></li></ul><li><a href="#PDENLPModels.jl-Documentation">PDENLPModels.jl Documentation</a></li><ul><li><a href="#Functions">Functions</a></li><li><a href="#Index">Index</a></li><li><a href="#References">References</a></li></ul><li><a href="nlpmodels/#PDENLPModels-Progress">PDENLPModels Progress</a></li></ul><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.EnergyFETerm" href="#PDENLPModels.EnergyFETerm"><code>PDENLPModels.EnergyFETerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>FETerm modeling the objective function of the optimization problem.</p><p class="math-container">\[\begin{equation}
\int_{\Omega} f(y,u) d\Omega,
\end{equation}\]</p><p>where Ω is described by:</p><ul><li>trian :: Triangulation</li><li>quad  :: CellQuadrature</li></ul><p>Constructor:</p><p><code>EnergyFETerm(:: Function, :: Triangulation, :: CellQuadrature)</code></p><p>See also: MixedEnergyFETerm, NoFETerm, _obj_cell_integral, _obj_integral, <em>compute\</em>gradient_k!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L160-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.GridapPDENLPModel" href="#PDENLPModels.GridapPDENLPModel"><code>PDENLPModels.GridapPDENLPModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>PDENLPModels using Gridap.jl</p><p>https://github.com/gridap/Gridap.jl Cite: Badia, S., &amp; Verdugo, F. (2020). Gridap: An extensible Finite Element toolbox in Julia. Journal of Open Source Software, 5(52), 2520.</p><p>Find functions (y,u): Y -&gt; ℜⁿ x ℜⁿ and κ ∈ ℜⁿ satisfying</p><p>min      ∫_Ω​ f(κ,y,u) dΩ​ s.t.     y solution of a PDE(κ,u)=0          lcon &lt;= c(κ,y,u) &lt;= ucon          lvar &lt;= (κ,y,u)  &lt;= uvar</p><pre><code class="language-none">     ```math
     \begin{aligned}
     \min_{κ,y,u} \ &amp; ∫_Ω​ f(κ,y,u) dΩ​ \\
     \mbox{ s.t. } &amp; y \mbox{ solution of } PDE(κ,u)=0, \\
     &amp; lcon &lt;= c(κ,y,u) &lt;= ucon, \\
     &amp; lvar &lt;= (κ,y,u)  &lt;= uvar.
     \end{aligned}
     ```</code></pre><p>The weak formulation is then: res((y,u),(v,q)) = ∫ v PDE(κ,y,u) + ∫ q c(κ,y,u)</p><p>where the unknown (y,u) is a MultiField see <a href="https://gridap.github.io/Tutorials/stable/pages/t007_darcy/">Tutorials 7</a>  and <a href="https://gridap.github.io/Tutorials/stable/pages/t008_inc_navier_stokes/">8</a> of Gridap.</p><p>The set Ω​ is represented here with <em>trian</em> and <em>quad</em>.</p><p>TODO: [ ] time evolution pde problems.    [ ] Handle the case where g and H are given.    [ ] Handle several terms in the objective function (via an FEOperator)?    [ ] Be more explicit on the different types of FETerm in  <em>from</em>term<em>to</em>terms!    [ ] Could we control the Dirichlet boundary condition? (like classical control of heat equations)    [ ] Clean the tests.    [ ] Missing: constraint ncon with num<em>free</em>dofs(Xpde)?   </p><p>Main constructor:</p><p><code>GridapPDENLPModel(:: NLPModelMeta, :: Counters, :: AbstractEnergyTerm, :: FESpace, :: Union{FESpace,Nothing}, :: FESpace, :: Union{FESpace,Nothing}, :: FESpace, :: Union{FESpace,Nothing}, :: Union{FEOperator, Nothing}, :: Int, :: Int, :: Int)</code></p><p>Additional constructors:</p><ul><li>Unconstrained and no control</li></ul><p>GridapPDENLPModel(x0, tnrj, Ypde, Xpde)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Xpde)     GridapPDENLPModel(f, trian, quad, Ypde, Xpde)   </p><ul><li>Bound constraints:   </li></ul><p>GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lvar, uvar)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Xpde, lvar, uvar)     GridapPDENLPModel(f, trian, quad, Ypde, Xpde, lvar, uvar)   </p><ul><li>PDE-constrained:   </li></ul><p>GridapPDENLPModel(x0, tnrj, Ypde, Xpde, c)     GridapPDENLPModel(Ypde, Xpde, c)     GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, c)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, c)     GridapPDENLPModel(f, trian, quad, Ypde, Ycon, Xpde, Xcon, c)     GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, c, lcon, ucon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, c, lcon, ucon)     GridapPDENLPModel(f, trian, quad, Ypde, Ycon, Xpde, Xcon, c, lcon, ucon)   </p><ul><li>PDE-constrained and bounds:   </li></ul><p>GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lvar, uvar, c)  GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c)     GridapPDENLPModel(f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c)     GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c, lcon, ucon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c, lcon, ucon)     GridapPDENLPModel(f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c, lcon, ucon)   </p><p><strong>Future constructors</strong>:</p><ul><li>Functional bounds: in this case |lvar|=|uvar|=nparam</li></ul><p>GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lfunc, ufunc)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Xpde, lfunc, ufunc)     GridapPDENLPModel(f, trian, quad, Ypde, Xpde, lfunc, ufunc)  GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lvar, uvar, lfunc, ufunc)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Xpde, lvar, uvar, lfunc, ufunc)     GridapPDENLPModel(f, trian, quad, Ypde, Xpde, lvar, uvar, lfunc, ufunc)   GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lvar, uvar, lfunc, ufunc, c)  GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c)     GridapPDENLPModel(f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c)     GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c, lcon, ucon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c, lcon, ucon)     GridapPDENLPModel(f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c, lcon, ucon)     </p><ul><li>Discrete constraints (ck, lckon, uckon) only for problems with nparam &gt; 0 (hence only if x0 given or tnrj)</li></ul><p>GridapPDENLPModel(x0, tnrj, Ypde, Xpde, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Xpde, ck, lckon, uckon)   GridapPDENLPModel(x0, tnrj, Ypde, Xpde, c, ck, lckon, uckon)   GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, c, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, c, ck, lckon, uckon)  GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, c, lcon, ucon, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, c, lcon, ucon, ck, lckon, uckon)    GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lvar, uvar, c, ck, lckon, uckon)  GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c, ck, lckon, uckon)   GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c, lcon, ucon, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, c, lcon, ucon, ck, lckon, uckon)   GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lfunc, ufunc, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Xpde, lfunc, ufunc, ck, lckon, uckon)   GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lvar, uvar, lfunc, ufunc, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Xpde, lvar, uvar, lfunc, ufunc, ck, lckon, uckon)  GridapPDENLPModel(x0, tnrj, Ypde, Xpde, lvar, uvar, lfunc, ufunc, c, ck, lckon, uckon)  GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c, ck, lckon, uckon)  GridapPDENLPModel(x0, tnrj, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c, lcon, ucon, ck, lckon, uckon)     GridapPDENLPModel(x0, f, trian, quad, Ypde, Ycon, Xpde, Xcon, lvar, uvar, lfunc, ufunc, c, lcon, ucon, ck, lckon, uckon)</p><p>The following keyword arguments are available to all constructors:</p><ul><li><code>name</code>: The name of the model (default: &quot;Generic&quot;)</li></ul><p>The following keyword arguments are available to the constructors for constrained problems:</p><ul><li><code>lin</code>: An array of indexes of the linear constraints</li></ul><p>(default: <code>Int[]</code> or 1:ncon if c is an AffineFEOperator)</p><p>The following keyword arguments are available to the constructors for constrained problems explictly giving lcon and ucon:</p><ul><li><code>y0</code>: An inital estimate to the Lagrangian multipliers (default: zeros)</li></ul><p>Notes:</p><ul><li>We handle two types of FEOperator: AffineFEOperator, and FEOperatorFromTerms</li></ul><p>which is the obtained by the FEOperator constructor.  The terms supported in FEOperatorFromTerms are: FESource, NonlinearFETerm,  NonlinearFETermWithAutodiff, LinearFETerm, AffineFETerm.</p><ul><li>If lcon and ucon are not given, they are assumed zeros.</li><li>If the type can&#39;t be deduced from the argument, it is Float64.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/GridapPDENLPModel.jl#L1-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.MixedEnergyFETerm" href="#PDENLPModels.MixedEnergyFETerm"><code>PDENLPModels.MixedEnergyFETerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>FETerm modeling the objective function of the optimization problem with functional and discrete unknowns.</p><p class="math-container">\[\begin{equation}
\int_{\Omega} f(y,u,\kappa) d\Omega,
\end{equation}\]</p><p>where Ω is described by:</p><ul><li>trian :: Triangulation</li><li>quad  :: CellQuadrature</li></ul><p>Constructor:</p><p><code>MixedEnergyFETerm(:: Function, :: Triangulation, :: CellQuadrature, :: Int)</code></p><p>See also: EnergyFETerm, NoFETerm, _obj_cell_integral, _obj_integral, _compute_gradient_k!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L278-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.NoFETerm" href="#PDENLPModels.NoFETerm"><code>PDENLPModels.NoFETerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>FETerm modeling the objective function when there are no intregral objective.</p><p><code>math \begin{equation}  f(\kappa) \end{equation}</code></p><p>Constructors:</p><p><code>NoFETerm()</code></p><p><code>NoFETerm(:: Function)</code></p><p>See also: MixedEnergyFETerm, EnergyFETerm, _obj_cell_integral, _obj_integral, _compute_gradient_k!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L77-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.ResidualEnergyFETerm" href="#PDENLPModels.ResidualEnergyFETerm"><code>PDENLPModels.ResidualEnergyFETerm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>FETerm modeling the objective function of the optimization problem with functional and discrete unknowns, describe as a norm and a regularizer.</p><p class="math-container">\[\begin{equation}
\frac{1}{2}\|Fyu(y,u)\|^2_{L^2_\Omega} + \lambda\int_{\Omega} lyu(y,u) d\Omega
 + \frac{1}{2}\|Fk(κ)\|^2 + \mu lk(κ)
\end{equation}\]</p><p>where Ω is described by:</p><ul><li>trian :: Triangulation</li><li>quad  :: CellQuadrature</li></ul><p>Constructor:</p><p><code>ResidualEnergyFETerm(:: Function, :: Triangulation, :: CellQuadrature, :: Function, :: Int)</code></p><p>See also: EnergyFETerm, NoFETerm, MixedEnergyFETerm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L581-L600">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.VoidFESpace" href="#PDENLPModels.VoidFESpace"><code>PDENLPModels.VoidFESpace</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Useful structure to avoid putting nothing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/PDENLPModels.jl#L18-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.jprod!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#NLPModels.jprod!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>NLPModels.jprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jv = jprod!(nlp, x, v, Jv)</code></pre><p>Evaluate <span>$J(x)v$</span>, the Jacobian-vector product at <code>x</code> in place.</p><p>Note for GridapPDENLPModel:</p><ul><li>Evaluate the jacobian and then use mul! (here coo_prod! is slower as we have to compute findnz).</li><li>Alternative: benefit from the AD? Jv .= ForwardDiff.derivative(t-&gt;nlp.c(nlp, x + t * v), 0)</li></ul><p>when the jacobian is obtained by AD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/GridapPDENLPModel.jl#L846-L854">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLPModels.jtprod!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#NLPModels.jtprod!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>NLPModels.jtprod!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jv = jtprod!(nlp, x, v, Jv)</code></pre><p>Evaluate <span>$J(x)&#39;v$</span>, the Jacobian-vector product at <code>x</code> in place.</p><p>Note for GridapPDENLPModel:</p><ul><li>Evaluate the jacobian and then use mul! (here coo_prod! is slower as we have to compute findnz).</li><li>Alternative: benefit from the AD? Jtv .= ForwardDiff.gradient(x -&gt; dot(nlp.c(x), v), x)</li></ul><p>when the jacobian is obtained by AD.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/GridapPDENLPModel.jl#L866-L874">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._compute_gradient!" href="#PDENLPModels._compute_gradient!"><code>PDENLPModels._compute_gradient!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the gradient of the objective function and set it in place.</p><p><code>_compute_gradient!(:: AbstractVector, :: EnergyFETerm, :: AbstractVector, :: FEFunctionType, :: FESpace, :: FESpace)</code></p><p>See also: MixedEnergyFETerm, EnergyFETerm, NoFETerm, <code>_obj_integral</code>, <code>_obj_cell_integral</code>, <code>_compute_hess_coo</code>, <code>_compute_hess_k_coo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L37-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._compute_gradient_k" href="#PDENLPModels._compute_gradient_k"><code>PDENLPModels._compute_gradient_k</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the derivative of the objective function w.r.t. κ.</p><p><code>_compute_gradient_k(:: AbstractEnergyTerm, :: FEFunctionType, :: AbstractVector)</code></p><p>See also: MixedEnergyFETerm, EnergyFETerm, NoFETerm, <code>_obj_integral</code>, <code>_obj_cell_integral</code>, <code>_compute_hess_coo</code>, <code>_compute_hess_k_coo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._compute_hess_coo" href="#PDENLPModels._compute_hess_coo"><code>PDENLPModels._compute_hess_coo</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the hessian w.r.t. yu of the objective function in coo format.</p><p><code>_compute_hess_coo(:: AbstractEnergyTerm, :: AbstractVector, :: FEFunctionType, :: FESpace, :: FESpace)</code></p><p>See also: MixedEnergyFETerm, EnergyFETerm, NoFETerm, <code>_obj_integral</code>, <code>_obj_cell_integral</code>, <code>_compute_gradient_k</code>, <code>_compute_hess_k_coo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L47-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._compute_hess_k_coo" href="#PDENLPModels._compute_hess_k_coo"><code>PDENLPModels._compute_hess_k_coo</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the hessian w.r.t. κ of the objective function in coo format.</p><p><code>_compute_hess_k_coo(:: AbstractNLPModel, :: AbstractEnergyTerm, :: AbstractVector, :: AbstractVector)</code></p><p>See also: MixedEnergyFETerm, EnergyFETerm, NoFETerm, <code>_obj_integral</code>, <code>_obj_cell_integral</code>, <code>_compute_gradient_k</code>, <code>_compute_hess_coo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._compute_hess_k_vals" href="#PDENLPModels._compute_hess_k_vals"><code>PDENLPModels._compute_hess_k_vals</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the values of the hessian w.r.t. κ of the objective function.</p><p><code>_compute_hess_k_vals(:: AbstractNLPModel, :: AbstractEnergyTerm, :: AbstractVector, :: AbstractVector)</code></p><p>See also: MixedEnergyFETerm, EnergyFETerm, NoFETerm, <code>_obj_integral</code>, <code>_obj_cell_integral</code>, <code>_compute_gradient_k</code>, <code>_compute_hess_coo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L67-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._fill_hess_at_cell!-Union{Tuple{Vi}, Tuple{Ii}, Tuple{M}, Tuple{Type{M},Any,AbstractArray{Ii,1},AbstractArray{Ii,1},AbstractArray{Vi,1},Any,Any,Any,Any}} where Vi&lt;:AbstractFloat where Ii&lt;:Integer where M" href="#PDENLPModels._fill_hess_at_cell!-Union{Tuple{Vi}, Tuple{Ii}, Tuple{M}, Tuple{Type{M},Any,AbstractArray{Ii,1},AbstractArray{Ii,1},AbstractArray{Vi,1},Any,Any,Any,Any}} where Vi&lt;:AbstractFloat where Ii&lt;:Integer where M"><code>PDENLPModels._fill_hess_at_cell!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://github.com/gridap/Gridap.jl/blob/758a8620756e164ba0e6b83dc8dcbb278015b3d9/src/FESpaces/SparseMatrixAssemblers.jl#L463 <em>fill</em>matrix<em>at</em>cell! may have a specific specialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/hessian_func.jl#L230-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._from_terms_to_jacobian-Union{Tuple{T}, Tuple{Gridap.FESpaces.FEOperatorFromTerms,AbstractArray{T,1},Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}} where T&lt;:Number" href="#PDENLPModels._from_terms_to_jacobian-Union{Tuple{T}, Tuple{Gridap.FESpaces.FEOperatorFromTerms,AbstractArray{T,1},Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}} where T&lt;:Number"><code>PDENLPModels._from_terms_to_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Note:</p><ol><li><p>Compute the derivatives w.r.t. y and u separately.</p></li><li><p>Use AD for those derivatives. Only for the following:</p></li></ol><ul><li>NonlinearFETerm (we neglect the inapropriate jac function);</li><li>NonlinearFETermWithAutodiff</li><li>TODO: Gridap.FESpaces.FETerm &amp; AffineFETerm ?</li><li>FESource &lt;: AffineFETerm (jacobian of a FESource is nothing)</li><li>LinearFETerm &lt;: AffineFETerm (not implemented)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/jacobian_func.jl#L179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._from_terms_to_jacobian2-Union{Tuple{T}, Tuple{Gridap.FESpaces.FEOperatorFromTerms,AbstractArray{T,1},GridapPDENLPModel}} where T&lt;:AbstractFloat" href="#PDENLPModels._from_terms_to_jacobian2-Union{Tuple{T}, Tuple{Gridap.FESpaces.FEOperatorFromTerms,AbstractArray{T,1},GridapPDENLPModel}} where T&lt;:AbstractFloat"><code>PDENLPModels._from_terms_to_jacobian2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Would be better but somehow autodiff<em>cell</em>jacobian<em>from</em>residual is restricted to square matrices at some point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_functions.jl#L103-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._from_terms_to_residual!-Tuple{Gridap.FESpaces.AffineFEOperator,AbstractArray{T,1} where T,GridapPDENLPModel,AbstractArray{T,1} where T}" href="#PDENLPModels._from_terms_to_residual!-Tuple{Gridap.FESpaces.AffineFEOperator,AbstractArray{T,1} where T,GridapPDENLPModel,AbstractArray{T,1} where T}"><code>PDENLPModels._from_terms_to_residual!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Note:</p><ul><li>mul! seems faster than doing:</li></ul><p>rows, cols, vals = findnz(get<em>matrix(op)) coo</em>prod!(cols, rows, vals, v, res)</p><ul><li>get_matrix(op) is a sparse matrix</li><li>Benchmark equivalent to Gridap.FESpaces.residual!(res, op_affine.op, xrand)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/GridapPDENLPModel.jl#L805-L813">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._functions_to_vectors!-Tuple{Integer,Integer,Gridap.Geometry.Triangulation,Function,Function,Gridap.Arrays.AppliedArray,Gridap.FESpaces.FESpace,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#PDENLPModels._functions_to_vectors!-Tuple{Integer,Integer,Gridap.Geometry.Triangulation,Function,Function,Gridap.Arrays.AppliedArray,Gridap.FESpaces.FESpace,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>PDENLPModels._functions_to_vectors!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><em>functions</em>to<em>vectors!(nini :: Int, nfields :: Int, trian :: Triangulation, lfunc :: Function, ufunc :: Function, cell</em>xm :: Gridap.Arrays.AppliedArray, Y :: FESpace, lvar :: AbstractVector, uvar :: AbstractVector)</p><p>Iterate for <code>k = 1</code> to <code>nfields</code> and switch <code>lfunc[k]</code> and <code>ufunc[k]</code> to vectors,  allocated in <code>lvar</code> and <code>uvar</code> in place starting from <code>nini + 1</code>. It returns nini + the number of allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/bounds_function.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._jac_structure!-Tuple{Gridap.FESpaces.FEOperatorFromTerms,GridapPDENLPModel,AbstractArray{var&quot;#s119&quot;,1} where var&quot;#s119&quot;&lt;:Integer,AbstractArray{var&quot;#s118&quot;,1} where var&quot;#s118&quot;&lt;:Integer}" href="#PDENLPModels._jac_structure!-Tuple{Gridap.FESpaces.FEOperatorFromTerms,GridapPDENLPModel,AbstractArray{var&quot;#s119&quot;,1} where var&quot;#s119&quot;&lt;:Integer,AbstractArray{var&quot;#s118&quot;,1} where var&quot;#s118&quot;&lt;:Integer}"><code>PDENLPModels._jac_structure!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adaptation of  <code>function allocate_matrix(a::SparseMatrixAssembler,matdata) end</code> in Gridap.FESpaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/GridapPDENLPModel.jl#L925-L929">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._obj_cell_integral" href="#PDENLPModels._obj_cell_integral"><code>PDENLPModels._obj_cell_integral</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the integral of the objective function</p><p><code>_obj_cell_integral(:: AbstractEnergyTerm, :: GenericCellField,  :: AbstractVector)</code></p><p>x is a vector of GenericCellField, for instance resulting from <code>yuh = CellField(Y, cell_yu)</code>.</p><p>See also: MixedEnergyFETerm, EnergyFETerm, NoFETerm, <code>_obj_integral</code>, <code>_compute_gradient_k</code>, <code>_compute_hess_coo</code>, <code>_compute_hess_k_coo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._obj_integral" href="#PDENLPModels._obj_integral"><code>PDENLPModels._obj_integral</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Return the integral of the objective function</p><p><code>_obj_integral(:: AbstractEnergyTerm, :: FEFunctionType, :: AbstractVector)</code></p><p>See also: MixedEnergyFETerm, EnergyFETerm, NoFETerm, <code>_obj_cell_integral</code>, <code>_compute_gradient_k</code>, <code>_compute_hess_coo</code>, <code>_compute_hess_k_coo</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_obj_terms.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._split_FEFunction-Tuple{AbstractArray{T,1} where T,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}" href="#PDENLPModels._split_FEFunction-Tuple{AbstractArray{T,1} where T,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}"><code>PDENLPModels._split_FEFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_split_FEFunction(:: AbstractVector,  :: FESpace, :: Union{FESpace, Nothing})</code></p><p>Split the vector x into two FEFunction corresponding to the solution <code>y</code> and the control <code>u</code>. Returns nothing for the control <code>u</code> if Ycon == nothing.</p><p>Do not verify the compatible length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/util_functions.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._split_vector-Tuple{AbstractArray{T,1} where T,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}" href="#PDENLPModels._split_vector-Tuple{AbstractArray{T,1} where T,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}"><code>PDENLPModels._split_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>_split_vector(:: AbstractVector,  :: FESpace, :: Union{FESpace, Nothing})</code></p><p>Split the vector x into three vectors: y, u, k. Returns nothing for the control <code>u</code> if Ycon == nothing.</p><p>Do not verify the compatible length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/util_functions.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._struct_hess_at_cell!-Union{Tuple{Ii}, Tuple{M}, Tuple{Type{M},Any,AbstractArray{Ii,1},AbstractArray{Ii,1},Any,Any,Any,Any,Any}} where Ii&lt;:Integer where M" href="#PDENLPModels._struct_hess_at_cell!-Union{Tuple{Ii}, Tuple{M}, Tuple{Type{M},Any,AbstractArray{Ii,1},AbstractArray{Ii,1},Any,Any,Any,Any,Any}} where Ii&lt;:Integer where M"><code>PDENLPModels._struct_hess_at_cell!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://github.com/gridap/Gridap.jl/blob/758a8620756e164ba0e6b83dc8dcbb278015b3d9/src/FESpaces/SparseMatrixAssemblers.jl#L463 <em>fill</em>matrix<em>at</em>cell! may have a specific specialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/hessian_func.jl#L307-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels._vals_hess_at_cell!-Union{Tuple{Vi}, Tuple{M}, Tuple{Type{M},Integer,AbstractArray{Vi,1},Any,Any,Any,Any}} where Vi&lt;:AbstractFloat where M" href="#PDENLPModels._vals_hess_at_cell!-Union{Tuple{Vi}, Tuple{M}, Tuple{Type{M},Integer,AbstractArray{Vi,1},Any,Any,Any,Any}} where Vi&lt;:AbstractFloat where M"><code>PDENLPModels._vals_hess_at_cell!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>https://github.com/gridap/Gridap.jl/blob/758a8620756e164ba0e6b83dc8dcbb278015b3d9/src/FESpaces/SparseMatrixAssemblers.jl#L463 <em>fill</em>matrix<em>at</em>cell! may have a specific specialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/hessian_func.jl#L380-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.assemble_hess-Union{Tuple{T}, Tuple{Gridap.FESpaces.GenericSparseMatrixAssembler,T,Gridap.Arrays.IdentityVector{Int64}}} where T&lt;:(AbstractArray{T,1} where T)" href="#PDENLPModels.assemble_hess-Union{Tuple{T}, Tuple{Gridap.FESpaces.GenericSparseMatrixAssembler,T,Gridap.Arrays.IdentityVector{Int64}}} where T&lt;:(AbstractArray{T,1} where T)"><code>PDENLPModels.assemble_hess</code></a> — <span class="docstring-category">Method</span></header><section><div><p>These functions: https://github.com/gridap/Gridap.jl/blob/758a8620756e164ba0e6b83dc8dcbb278015b3d9/src/FESpaces/SparseMatrixAssemblers.jl#L463</p><p>https://github.com/gridap/Gridap.jl/blob/758a8620756e164ba0e6b83dc8dcbb278015b3d9/src/Algebra/SparseMatrixCSC.jl</p><p>https://github.com/gridap/Gridap.jl/blob/758a8620756e164ba0e6b83dc8dcbb278015b3d9/src/Algebra/SparseMatrices.jl#L29-L33</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/hessian_func.jl#L10-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.assemble_jac_vals!-Tuple{Any,Gridap.FESpaces.GenericSparseMatrixAssembler,Any}" href="#PDENLPModels.assemble_jac_vals!-Tuple{Any,Gridap.FESpaces.GenericSparseMatrixAssembler,Any}"><code>PDENLPModels.assemble_jac_vals!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Adaptation of <code>function assemble_matrix_add!(mat,a::GenericSparseMatrixAssembler,matdata) end</code> from Gridap.FESpaces</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/jacobian_func.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.bounds_functions_to_vectors-Tuple{Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.Geometry.Triangulation,Function,Function,Function,Function}" href="#PDENLPModels.bounds_functions_to_vectors-Tuple{Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.Geometry.Triangulation,Function,Function,Function,Function}"><code>PDENLPModels.bounds_functions_to_vectors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>(lvar, uvar) = bounds<em>functions</em>to_vectors(Y :: MultiFieldFESpace, Ycon :: Union{FESpace, Nothing},  Ypde :: FESpace, trian :: Triangulation, lyfunc :: Union{Function, AbstractVector}, uyfunc :: Union{Function, AbstractVector}, lufunc :: Union{Function, AbstractVector}, uufunc :: Union{Function, AbstractVector})</p><p>Return the bounds <code>lvar</code> and <code>uvar</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/bounds_function.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.count_nnz_coo_short-Tuple{Gridap.FESpaces.GenericSparseMatrixAssembler,Any}" href="#PDENLPModels.count_nnz_coo_short-Tuple{Gridap.FESpaces.GenericSparseMatrixAssembler,Any}"><code>PDENLPModels.count_nnz_coo_short</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is a modified version of <code>function count_matrix_nnz_coo(a::GenericSparseMatrixAssembler,matdata) end</code> from Gridap.FESpaces. The motivation is to avoid the use of the yet unknown values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/jacobian_func.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.fill_jac_coo_symbolic!-Tuple{Any,Any,Gridap.FESpaces.GenericSparseMatrixAssembler,Any}" href="#PDENLPModels.fill_jac_coo_symbolic!-Tuple{Any,Any,Gridap.FESpaces.GenericSparseMatrixAssembler,Any}"><code>PDENLPModels.fill_jac_coo_symbolic!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is a modified version of <code>function fill_matrix_coo_symbolic!(I,J,a::GenericSparseMatrixAssembler,matdata,n=0) end</code> from Gridap.FESpaces. The motivation is to avoid the use of the yet unknown values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/jacobian_func.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.get_nnzh-Union{Tuple{T}, Tuple{T,Any,Any,Any,Any}} where T" href="#PDENLPModels.get_nnzh-Union{Tuple{T}, Tuple{T,Any,Any,Any,Any}} where T"><code>PDENLPModels.get_nnzh</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_nnzh</code>: return the number of non-zeros elements in the hessian matrix.</p><p>Different variants:</p><ul><li><code>get_nnzh(tnrj :: T, Y, X, nparam, nvar)</code>: consider the hessian of the </li></ul><p>objective function only.   </p><ul><li><code>get_nnzh(tnrj :: T, op :: AffineFEOperator, Y, X, nparam, nvar)</code>: consider </li></ul><p>the hessian of the objective function only.    </p><ul><li><code>get_nnzh(tnrj :: T, op :: Gridap.FESpaces.FEOperatorFromTerms, Y, X, nparam, nvar)</code>: </li></ul><p>concatenate non-zeros of the objective-hessian and the hessian of each term composing <code>op</code>.    </p><p>TODO: Do not handle non-linear discrete parameters in the constraints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/hessian_func.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.hess_coo-Tuple{GridapPDENLPModel,Gridap.FESpaces.AffineFEOperator,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#PDENLPModels.hess_coo-Tuple{GridapPDENLPModel,Gridap.FESpaces.AffineFEOperator,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>PDENLPModels.hess_coo</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>hess_coo</code>: return the hessian of the constraints in COO-format.</p><p>Notes:    </p><ul><li><code>hess_coo(nlp, op :: AffineFEOperator, x, λ)</code>: return 0-matrix</li><li><code>hess_coo(nlp, op :: FEOperatorFromTerms, x, λ)</code>: iterate over the terms</li></ul><p>TODO: make it a real COO-format function.</p><p>do not work with parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/GridapPDENLPModel.jl#L527-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.hess_obj_structure-Tuple{GridapPDENLPModel}" href="#PDENLPModels.hess_obj_structure-Tuple{GridapPDENLPModel}"><code>PDENLPModels.hess_obj_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>hess_structure</code> returns the sparsity pattern of the Lagrangian Hessian  in sparse coordinate format, and <code>hess_obj_structure</code> is only for the objective function hessian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/GridapPDENLPModel.jl#L300-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.hess_old-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T}" href="#PDENLPModels.hess_old-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T}"><code>PDENLPModels.hess_old</code></a> — <span class="docstring-category">Method</span></header><section><div><p>julia&gt; @btime hess(nlp, sol_gridap);   614.938 ms (724536 allocations: 90.46 MiB)</p><p>julia&gt; @btime hess<em>old(nlp, sol</em>gridap);   643.689 ms (724599 allocations: 127.48 MiB)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_functions.jl#L65-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.hessian_lagrangian_test_functions-Tuple{GridapPDENLPModel}" href="#PDENLPModels.hessian_lagrangian_test_functions-Tuple{GridapPDENLPModel}"><code>PDENLPModels.hessian_lagrangian_test_functions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function testing all the Lagrangian Hessian-related function implemented for GridapPDENLPModel.</p><ul><li>return true if the test passed.</li><li>set <code>udc</code> to true to use NLPModels derivative check (can be slow)</li></ul><p>https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/master/src/dercheck.jl</p><ul><li>should be used for small problems only as it computes hessians several times.</li></ul><p>We test the functions from hessian_func.jl and normal test functions.</p><p>List of functions we are testing:</p><ul><li><code>hess_coo</code> ✓</li><li><code>hess</code> ✓</li><li><code>hess_obj_structure</code> ✓</li><li><code>hess_coord</code> and <code>hess_coord!</code> ✓</li><li><code>hprod</code> ✓</li><li><code>hess_op</code> and <code>hess_op!</code> ✓</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/hessian_lag_test_functions.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.hessian_test_functions-Tuple{GridapPDENLPModel}" href="#PDENLPModels.hessian_test_functions-Tuple{GridapPDENLPModel}"><code>PDENLPModels.hessian_test_functions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function testing all the hessian-related function implemented for GridapPDENLPModel.</p><ul><li>return true if the test passed.</li><li>set <code>udc</code> to true to use NLPModels derivative check (can be slow)</li></ul><p>https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/master/src/dercheck.jl</p><ul><li>should be used for small problems only as it computes hessians several times.</li></ul><p>We test the functions from hessian_func.jl and normal test functions.</p><p>List of functions we are testing:</p><ul><li><code>hess_coo</code> ✓</li><li><code>hess</code> ✓</li><li><code>hess_obj_structure</code> and  <code>hess_obj_structure!</code> ✓</li><li><code>hess_coord</code> and <code>hess_coord!</code> ✓</li><li><code>count_hess_nnz_coo_short</code> ✓</li><li><code>hprod</code> ✓</li><li><code>hess_op</code> and <code>hess_op!</code> ✓</li></ul><p>Comments:</p><ul><li>set the number of &quot;nnzh&quot; (with the repeated entries?) in the META? Note, this is</li></ul><p>necessary to have <code>hess_structure!</code> and <code>hess_coord!</code>.</p><ul><li><code>count_hess_nnz_coo</code> is used in the computation of <code>hess_coo</code> instead of</li></ul><p><code>count_hess_nnz_coo_short</code>, so if there is a difference it would appear in the tests (implicit test).</p><ul><li>Use sparse differentiation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/hessian_test_functions.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.hprod_autodiff!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#PDENLPModels.hprod_autodiff!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>PDENLPModels.hprod_autodiff!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute hessian-vector product of the objective function.</p><p>Note: this is not efficient at all. Test on n=14115 @btime hprod(nlp, sol<em>gridap, v)   42.683 s (274375613 allocations: 29.89 GiB) while computing the hessian and then the product yields @btime _Hx = hess(nlp, sol</em>gridap);   766.036 ms (724829 allocations: 121.84 MiB) @btime hprod(nlp, sol_gridap, v)   42.683 s (274375613 allocations: 29.89 GiB)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/additional_functions.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PDENLPModels.jacobian_test_functions-Tuple{GridapPDENLPModel}" href="#PDENLPModels.jacobian_test_functions-Tuple{GridapPDENLPModel}"><code>PDENLPModels.jacobian_test_functions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function testing all the jacobian-related function implemented for GridapPDENLPModel.</p><ul><li>return true if the test passed.</li><li>set <code>udc</code> to true to use NLPModels derivative check (can be slow)</li></ul><p>https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/master/src/dercheck.jl</p><ul><li>should be used for small problems only as it computes hessians several times.</li></ul><p>We test the functions from jacobian_func.jl and normal test functions.</p><p>List of functions we are testing:</p><ul><li><code>jac</code> ✓</li><li><code>jac_structure</code> and  <code>jac_structure!</code> ✓</li><li><code>jac_coord</code> and <code>jac_coord!</code> ✓</li><li><code>count_nnz_jac</code> ✓</li><li><code>jprod</code> and <code>jtprod</code> </li><li><code>jac_op</code> and <code>jac_op!</code> ✓</li></ul><p>Comments:</p><ul><li>set the number of &quot;nnzh&quot; (with the repeated entries?) in the META?</li><li>Use sparse differentiation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tmigot/PDENLPModels.jl/blob/29a435fabfd0022cda5c67bca3abe31bc62ae121/src/jacobian_test_functions.jl#L1-L22">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#PDENLPModels.EnergyFETerm"><code>PDENLPModels.EnergyFETerm</code></a></li><li><a href="#PDENLPModels.GridapPDENLPModel"><code>PDENLPModels.GridapPDENLPModel</code></a></li><li><a href="#PDENLPModels.MixedEnergyFETerm"><code>PDENLPModels.MixedEnergyFETerm</code></a></li><li><a href="#PDENLPModels.NoFETerm"><code>PDENLPModels.NoFETerm</code></a></li><li><a href="#PDENLPModels.ResidualEnergyFETerm"><code>PDENLPModels.ResidualEnergyFETerm</code></a></li><li><a href="#PDENLPModels.VoidFESpace"><code>PDENLPModels.VoidFESpace</code></a></li><li><a href="#NLPModels.jprod!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>NLPModels.jprod!</code></a></li><li><a href="#NLPModels.jtprod!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>NLPModels.jtprod!</code></a></li><li><a href="#PDENLPModels._compute_gradient!"><code>PDENLPModels._compute_gradient!</code></a></li><li><a href="#PDENLPModels._compute_gradient_k"><code>PDENLPModels._compute_gradient_k</code></a></li><li><a href="#PDENLPModels._compute_hess_coo"><code>PDENLPModels._compute_hess_coo</code></a></li><li><a href="#PDENLPModels._compute_hess_k_coo"><code>PDENLPModels._compute_hess_k_coo</code></a></li><li><a href="#PDENLPModels._compute_hess_k_vals"><code>PDENLPModels._compute_hess_k_vals</code></a></li><li><a href="#PDENLPModels._fill_hess_at_cell!-Union{Tuple{Vi}, Tuple{Ii}, Tuple{M}, Tuple{Type{M},Any,AbstractArray{Ii,1},AbstractArray{Ii,1},AbstractArray{Vi,1},Any,Any,Any,Any}} where Vi&lt;:AbstractFloat where Ii&lt;:Integer where M"><code>PDENLPModels._fill_hess_at_cell!</code></a></li><li><a href="#PDENLPModels._from_terms_to_jacobian-Union{Tuple{T}, Tuple{Gridap.FESpaces.FEOperatorFromTerms,AbstractArray{T,1},Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}} where T&lt;:Number"><code>PDENLPModels._from_terms_to_jacobian</code></a></li><li><a href="#PDENLPModels._from_terms_to_jacobian2-Union{Tuple{T}, Tuple{Gridap.FESpaces.FEOperatorFromTerms,AbstractArray{T,1},GridapPDENLPModel}} where T&lt;:AbstractFloat"><code>PDENLPModels._from_terms_to_jacobian2</code></a></li><li><a href="#PDENLPModels._from_terms_to_residual!-Tuple{Gridap.FESpaces.AffineFEOperator,AbstractArray{T,1} where T,GridapPDENLPModel,AbstractArray{T,1} where T}"><code>PDENLPModels._from_terms_to_residual!</code></a></li><li><a href="#PDENLPModels._functions_to_vectors!-Tuple{Integer,Integer,Gridap.Geometry.Triangulation,Function,Function,Gridap.Arrays.AppliedArray,Gridap.FESpaces.FESpace,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>PDENLPModels._functions_to_vectors!</code></a></li><li><a href="#PDENLPModels._jac_structure!-Tuple{Gridap.FESpaces.FEOperatorFromTerms,GridapPDENLPModel,AbstractArray{var&quot;#s119&quot;,1} where var&quot;#s119&quot;&lt;:Integer,AbstractArray{var&quot;#s118&quot;,1} where var&quot;#s118&quot;&lt;:Integer}"><code>PDENLPModels._jac_structure!</code></a></li><li><a href="#PDENLPModels._obj_cell_integral"><code>PDENLPModels._obj_cell_integral</code></a></li><li><a href="#PDENLPModels._obj_integral"><code>PDENLPModels._obj_integral</code></a></li><li><a href="#PDENLPModels._split_FEFunction-Tuple{AbstractArray{T,1} where T,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}"><code>PDENLPModels._split_FEFunction</code></a></li><li><a href="#PDENLPModels._split_vector-Tuple{AbstractArray{T,1} where T,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace}"><code>PDENLPModels._split_vector</code></a></li><li><a href="#PDENLPModels._struct_hess_at_cell!-Union{Tuple{Ii}, Tuple{M}, Tuple{Type{M},Any,AbstractArray{Ii,1},AbstractArray{Ii,1},Any,Any,Any,Any,Any}} where Ii&lt;:Integer where M"><code>PDENLPModels._struct_hess_at_cell!</code></a></li><li><a href="#PDENLPModels._vals_hess_at_cell!-Union{Tuple{Vi}, Tuple{M}, Tuple{Type{M},Integer,AbstractArray{Vi,1},Any,Any,Any,Any}} where Vi&lt;:AbstractFloat where M"><code>PDENLPModels._vals_hess_at_cell!</code></a></li><li><a href="#PDENLPModels.assemble_hess-Union{Tuple{T}, Tuple{Gridap.FESpaces.GenericSparseMatrixAssembler,T,Gridap.Arrays.IdentityVector{Int64}}} where T&lt;:(AbstractArray{T,1} where T)"><code>PDENLPModels.assemble_hess</code></a></li><li><a href="#PDENLPModels.assemble_jac_vals!-Tuple{Any,Gridap.FESpaces.GenericSparseMatrixAssembler,Any}"><code>PDENLPModels.assemble_jac_vals!</code></a></li><li><a href="#PDENLPModels.bounds_functions_to_vectors-Tuple{Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.FESpaces.FESpace,Gridap.Geometry.Triangulation,Function,Function,Function,Function}"><code>PDENLPModels.bounds_functions_to_vectors</code></a></li><li><a href="#PDENLPModels.count_nnz_coo_short-Tuple{Gridap.FESpaces.GenericSparseMatrixAssembler,Any}"><code>PDENLPModels.count_nnz_coo_short</code></a></li><li><a href="#PDENLPModels.fill_jac_coo_symbolic!-Tuple{Any,Any,Gridap.FESpaces.GenericSparseMatrixAssembler,Any}"><code>PDENLPModels.fill_jac_coo_symbolic!</code></a></li><li><a href="#PDENLPModels.get_nnzh-Union{Tuple{T}, Tuple{T,Any,Any,Any,Any}} where T"><code>PDENLPModels.get_nnzh</code></a></li><li><a href="#PDENLPModels.hess_coo-Tuple{GridapPDENLPModel,Gridap.FESpaces.AffineFEOperator,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>PDENLPModels.hess_coo</code></a></li><li><a href="#PDENLPModels.hess_obj_structure-Tuple{GridapPDENLPModel}"><code>PDENLPModels.hess_obj_structure</code></a></li><li><a href="#PDENLPModels.hess_old-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T}"><code>PDENLPModels.hess_old</code></a></li><li><a href="#PDENLPModels.hessian_lagrangian_test_functions-Tuple{GridapPDENLPModel}"><code>PDENLPModels.hessian_lagrangian_test_functions</code></a></li><li><a href="#PDENLPModels.hessian_test_functions-Tuple{GridapPDENLPModel}"><code>PDENLPModels.hessian_test_functions</code></a></li><li><a href="#PDENLPModels.hprod_autodiff!-Tuple{GridapPDENLPModel,AbstractArray{T,1} where T,AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>PDENLPModels.hprod_autodiff!</code></a></li><li><a href="#PDENLPModels.jacobian_test_functions-Tuple{GridapPDENLPModel}"><code>PDENLPModels.jacobian_test_functions</code></a></li></ul><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>https://github.com/gridap/Gridap.jl Badia, S., &amp; Verdugo, F. (2020). Gridap: An extensible Finite Element toolbox in Julia. Journal of Open Source Software, 5(52), 2520.</p><p>https://github.com/JuliaSmoothOptimizers/NLPModels.jl D. Orban and A. S. Siqueira and {contributors} (2020). NLPModels.jl: Data Structures for Optimization Models</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="nlpmodels/">PDENLPModels Progress »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 1 April 2021 04:41">Thursday 1 April 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
